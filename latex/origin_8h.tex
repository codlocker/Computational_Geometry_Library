\hypertarget{origin_8h}{}\section{origin.\+h File Reference}
\label{origin_8h}\index{origin.\+h@{origin.\+h}}
{\ttfamily \#include $<$iostream$>$}\\*
{\ttfamily \#include $<$bits/stdc++.\+h$>$}\\*
Include dependency graph for origin.\+h\+:
% FIG 0
This graph shows which files directly or indirectly include this file\+:
% FIG 1
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{origin_8h_a2a1803d02747e2d698a94307ffd6699b}{ull}~unsigned long long
\item 
\#define \hyperlink{origin_8h_a276c5a0e984cf60015b27252fe04fe6b}{pb}~push\+\_\+back
\item 
\#define \hyperlink{origin_8h_aea466a7139309b17bce61d5ccb03e195}{mp}~make\+\_\+pair
\item 
\#define \hyperlink{origin_8h_a105caa178db222564f6fab1433ae289b}{C\+O\+L\+L\+I\+N\+E\+AR}~1
\item 
\#define \hyperlink{origin_8h_ab97a98583824a9ef7d480fe8fdca33cf}{C\+L\+O\+C\+K\+W\+I\+SE}~2
\item 
\#define \hyperlink{origin_8h_a289ba85c8fefbfdb6cc4927dbf948940}{A\+N\+T\+I\+C\+L\+O\+C\+K\+W\+I\+SE}~3
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
double \hyperlink{origin_8h_afcdcfb840d57ba04a9c8ddc76e90ce98}{calc\+Euclid\+Distance} (pair$<$ double, double $>$ fpoint, pair$<$ double, double $>$ spoint)
\begin{DoxyCompactList}\small\item\em Euclidean Distance. \end{DoxyCompactList}\item 
int \hyperlink{origin_8h_a6edb8cd3a06d478bf1b50ae13f8af565}{orientation} (pair$<$ double, double $>$ a, pair$<$ double, double $>$ b, pair$<$ double, double $>$ c)
\begin{DoxyCompactList}\small\item\em Orientation. \end{DoxyCompactList}\item 
bool \hyperlink{origin_8h_acd5236039bd3f25f48a6f9638caca9e9}{ordered\+Sort} (pair$<$ double, double $>$ \&f, pair$<$ double, double $>$ \&s)
\begin{DoxyCompactList}\small\item\em Comparator Function. \end{DoxyCompactList}\item 
bool \hyperlink{origin_8h_a4dc1f0518995effb5aa220fd58f3b8e8}{ordered\+Y\+Sort} (pair$<$ double, double $>$ \&f, pair$<$ double, double $>$ \&s)
\begin{DoxyCompactList}\small\item\em Comparator Function Sort by y coordinate. \end{DoxyCompactList}\item 
bool \hyperlink{origin_8h_ab4d553464b44f7c3f45a7ad69b98772c}{order\+By\+Polar} (pair$<$ double, double $>$ \&p1, pair$<$ double, double $>$ \&p2)
\begin{DoxyCompactList}\small\item\em Function to order with respect to polar Coordinates. \end{DoxyCompactList}\item 
void \hyperlink{origin_8h_a4d6ea05a2f5f54cf53c8ce3687f0ae92}{print\+Vector\+Data} (int len, vector$<$ pair$<$ double, double $>$ $>$ v, string s)
\begin{DoxyCompactList}\small\item\em Print Function. \end{DoxyCompactList}\item 
vector$<$ pair$<$ double, double $>$ $>$ \hyperlink{origin_8h_afa3779aba8d21a4aca29b38a893f5881}{get\+Data} (char $\ast$filename)
\begin{DoxyCompactList}\small\item\em Extract Data from Input File. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
vector$<$ int $>$ \hyperlink{origin_8h_a09f477f5f8ac23bab833383ce19845e2}{indices}
\end{DoxyCompactItemize}
{\bf }\par
\begin{DoxyCompactItemize}
\item 
pair$<$ double,double $>$ \hyperlink{origin_8h_adacb3282d7a9fb184f695409085f0f0c}{P0}
\begin{DoxyCompactList}\small\item\em a double value which stores the centre about which polar ordering is to be done \end{DoxyCompactList}\end{DoxyCompactItemize}



\subsection{Macro Definition Documentation}
\index{origin.\+h@{origin.\+h}!A\+N\+T\+I\+C\+L\+O\+C\+K\+W\+I\+SE@{A\+N\+T\+I\+C\+L\+O\+C\+K\+W\+I\+SE}}
\index{A\+N\+T\+I\+C\+L\+O\+C\+K\+W\+I\+SE@{A\+N\+T\+I\+C\+L\+O\+C\+K\+W\+I\+SE}!origin.\+h@{origin.\+h}}
\subsubsection[{\texorpdfstring{A\+N\+T\+I\+C\+L\+O\+C\+K\+W\+I\+SE}{ANTICLOCKWISE}}]{\setlength{\rightskip}{0pt plus 5cm}\#define A\+N\+T\+I\+C\+L\+O\+C\+K\+W\+I\+SE~3}\hypertarget{origin_8h_a289ba85c8fefbfdb6cc4927dbf948940}{}\label{origin_8h_a289ba85c8fefbfdb6cc4927dbf948940}
Macro defined for identifying 3 points that rotate anticlockwise \index{origin.\+h@{origin.\+h}!C\+L\+O\+C\+K\+W\+I\+SE@{C\+L\+O\+C\+K\+W\+I\+SE}}
\index{C\+L\+O\+C\+K\+W\+I\+SE@{C\+L\+O\+C\+K\+W\+I\+SE}!origin.\+h@{origin.\+h}}
\subsubsection[{\texorpdfstring{C\+L\+O\+C\+K\+W\+I\+SE}{CLOCKWISE}}]{\setlength{\rightskip}{0pt plus 5cm}\#define C\+L\+O\+C\+K\+W\+I\+SE~2}\hypertarget{origin_8h_ab97a98583824a9ef7d480fe8fdca33cf}{}\label{origin_8h_ab97a98583824a9ef7d480fe8fdca33cf}
Macro defined for identifying 3 points that rotate clockwise \index{origin.\+h@{origin.\+h}!C\+O\+L\+L\+I\+N\+E\+AR@{C\+O\+L\+L\+I\+N\+E\+AR}}
\index{C\+O\+L\+L\+I\+N\+E\+AR@{C\+O\+L\+L\+I\+N\+E\+AR}!origin.\+h@{origin.\+h}}
\subsubsection[{\texorpdfstring{C\+O\+L\+L\+I\+N\+E\+AR}{COLLINEAR}}]{\setlength{\rightskip}{0pt plus 5cm}\#define C\+O\+L\+L\+I\+N\+E\+AR~1}\hypertarget{origin_8h_a105caa178db222564f6fab1433ae289b}{}\label{origin_8h_a105caa178db222564f6fab1433ae289b}
Macro defined for identifying 3 collinear points \index{origin.\+h@{origin.\+h}!mp@{mp}}
\index{mp@{mp}!origin.\+h@{origin.\+h}}
\subsubsection[{\texorpdfstring{mp}{mp}}]{\setlength{\rightskip}{0pt plus 5cm}\#define mp~make\+\_\+pair}\hypertarget{origin_8h_aea466a7139309b17bce61d5ccb03e195}{}\label{origin_8h_aea466a7139309b17bce61d5ccb03e195}
Macro for making my typing life easier \index{origin.\+h@{origin.\+h}!pb@{pb}}
\index{pb@{pb}!origin.\+h@{origin.\+h}}
\subsubsection[{\texorpdfstring{pb}{pb}}]{\setlength{\rightskip}{0pt plus 5cm}\#define pb~push\+\_\+back}\hypertarget{origin_8h_a276c5a0e984cf60015b27252fe04fe6b}{}\label{origin_8h_a276c5a0e984cf60015b27252fe04fe6b}
Macro for making my typing life easier \index{origin.\+h@{origin.\+h}!ull@{ull}}
\index{ull@{ull}!origin.\+h@{origin.\+h}}
\subsubsection[{\texorpdfstring{ull}{ull}}]{\setlength{\rightskip}{0pt plus 5cm}\#define ull~unsigned long long}\hypertarget{origin_8h_a2a1803d02747e2d698a94307ffd6699b}{}\label{origin_8h_a2a1803d02747e2d698a94307ffd6699b}
Macro for making my typing life easier 

\subsection{Function Documentation}
\index{origin.\+h@{origin.\+h}!calc\+Euclid\+Distance@{calc\+Euclid\+Distance}}
\index{calc\+Euclid\+Distance@{calc\+Euclid\+Distance}!origin.\+h@{origin.\+h}}
\subsubsection[{\texorpdfstring{calc\+Euclid\+Distance(pair$<$ double, double $>$ fpoint, pair$<$ double, double $>$ spoint)}{calcEuclidDistance(pair< double, double > fpoint, pair< double, double > spoint)}}]{\setlength{\rightskip}{0pt plus 5cm}double calc\+Euclid\+Distance (
\begin{DoxyParamCaption}
\item[{pair$<$ double, double $>$}]{fpoint, }
\item[{pair$<$ double, double $>$}]{spoint}
\end{DoxyParamCaption}
)}\hypertarget{origin_8h_afcdcfb840d57ba04a9c8ddc76e90ce98}{}\label{origin_8h_afcdcfb840d57ba04a9c8ddc76e90ce98}


Euclidean Distance. 

This function is used to calculate the distance between two points which is $\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}$. 
\begin{DoxyCode}
23                                                                                     \{
24     \textcolor{keywordtype}{double} dist;
25     dist = sqrt(pow((fpoint.first-spoint.first),2.0) + pow((fpoint.second-spoint.second),2.0));
26     \textcolor{keywordflow}{return} dist;
27 \}
\end{DoxyCode}
\index{origin.\+h@{origin.\+h}!get\+Data@{get\+Data}}
\index{get\+Data@{get\+Data}!origin.\+h@{origin.\+h}}
\subsubsection[{\texorpdfstring{get\+Data(char $\ast$filename)}{getData(char *filename)}}]{\setlength{\rightskip}{0pt plus 5cm}vector$<$pair$<$double, double$>$ $>$ get\+Data (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{filename}
\end{DoxyParamCaption}
)}\hypertarget{origin_8h_afa3779aba8d21a4aca29b38a893f5881}{}\label{origin_8h_afa3779aba8d21a4aca29b38a893f5881}


Extract Data from Input File. 

It extracts Data From a file and stores it in a vector for further calculation. Forms the base for getting Data. 
\begin{DoxyCode}
113                                                       \{
114     vector<pair<double, double> > input;
115     \textcolor{keywordtype}{double} a,b;
116     ifstream in\_file;
117     in\_file.open(filename);
118     \textcolor{keywordflow}{while} (in\_file.is\_open()) \{
119         \textcolor{keywordtype}{int} n;
120         in\_file >> n;
121         \textcolor{keywordflow}{while}(in\_file >> a >> b) \{
122             input.pb(\hyperlink{origin_8h_aea466a7139309b17bce61d5ccb03e195}{mp}(a,b));
123         \}
124         in\_file.close();
125     \}
126     \textcolor{keywordflow}{return} input;
127 \}
\end{DoxyCode}
\index{origin.\+h@{origin.\+h}!order\+By\+Polar@{order\+By\+Polar}}
\index{order\+By\+Polar@{order\+By\+Polar}!origin.\+h@{origin.\+h}}
\subsubsection[{\texorpdfstring{order\+By\+Polar(pair$<$ double, double $>$ \&p1, pair$<$ double, double $>$ \&p2)}{orderByPolar(pair< double, double > &p1, pair< double, double > &p2)}}]{\setlength{\rightskip}{0pt plus 5cm}bool order\+By\+Polar (
\begin{DoxyParamCaption}
\item[{pair$<$ double, double $>$ \&}]{p1, }
\item[{pair$<$ double, double $>$ \&}]{p2}
\end{DoxyParamCaption}
)}\hypertarget{origin_8h_ab4d553464b44f7c3f45a7ad69b98772c}{}\label{origin_8h_ab4d553464b44f7c3f45a7ad69b98772c}


Function to order with respect to polar Coordinates. 

function used by this algorithm to sort an array of points with respect to the first point in the vector. 
\begin{DoxyCode}
87                                                                    \{
88     \textcolor{keywordtype}{int} oValue  = \hyperlink{origin_8h_a6edb8cd3a06d478bf1b50ae13f8af565}{orientation}(\hyperlink{origin_8h_adacb3282d7a9fb184f695409085f0f0c}{P0},p2,p1);
89     cout << \textcolor{stringliteral}{"comparing "} << \textcolor{stringliteral}{"("} << \hyperlink{origin_8h_adacb3282d7a9fb184f695409085f0f0c}{P0}.first << \textcolor{stringliteral}{", "} << \hyperlink{origin_8h_adacb3282d7a9fb184f695409085f0f0c}{P0}.second <<\textcolor{stringliteral}{")"} <<  \textcolor{stringliteral}{" "}
90          << \textcolor{stringliteral}{"("} << p1.first << \textcolor{stringliteral}{", "} << p1.second <<\textcolor{stringliteral}{")"} << \textcolor{stringliteral}{" "}
91          << \textcolor{stringliteral}{"("} << p2.first << \textcolor{stringliteral}{", "} << p2.second <<\textcolor{stringliteral}{")"} <<endl;
92     cout << \textcolor{stringliteral}{" The orientation value is "} << oValue << endl;
93     \textcolor{keywordflow}{if}(oValue == 1) \{
94         cout << \textcolor{stringliteral}{"Result :"} << (\hyperlink{origin_8h_afcdcfb840d57ba04a9c8ddc76e90ce98}{calcEuclidDistance}(\hyperlink{origin_8h_adacb3282d7a9fb184f695409085f0f0c}{P0},p2) >= 
      \hyperlink{origin_8h_afcdcfb840d57ba04a9c8ddc76e90ce98}{calcEuclidDistance}(\hyperlink{origin_8h_adacb3282d7a9fb184f695409085f0f0c}{P0},p1)) <<endl;
95         \textcolor{keywordflow}{return} (\hyperlink{origin_8h_afcdcfb840d57ba04a9c8ddc76e90ce98}{calcEuclidDistance}(\hyperlink{origin_8h_adacb3282d7a9fb184f695409085f0f0c}{P0},p2) < 
      \hyperlink{origin_8h_afcdcfb840d57ba04a9c8ddc76e90ce98}{calcEuclidDistance}(\hyperlink{origin_8h_adacb3282d7a9fb184f695409085f0f0c}{P0},p1));
96     \}
97     \textcolor{keywordflow}{return} (oValue != 3);
98 \}
\end{DoxyCode}
\index{origin.\+h@{origin.\+h}!ordered\+Sort@{ordered\+Sort}}
\index{ordered\+Sort@{ordered\+Sort}!origin.\+h@{origin.\+h}}
\subsubsection[{\texorpdfstring{ordered\+Sort(pair$<$ double, double $>$ \&f, pair$<$ double, double $>$ \&s)}{orderedSort(pair< double, double > &f, pair< double, double > &s)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ordered\+Sort (
\begin{DoxyParamCaption}
\item[{pair$<$ double, double $>$ \&}]{f, }
\item[{pair$<$ double, double $>$ \&}]{s}
\end{DoxyParamCaption}
)}\hypertarget{origin_8h_acd5236039bd3f25f48a6f9638caca9e9}{}\label{origin_8h_acd5236039bd3f25f48a6f9638caca9e9}


Comparator Function. 

This function basically compares a pair of elements by the values of their x-\/coordinate and if x-\/xoordinate is equal then it checks for equality of y-\/coordinate 
\begin{DoxyCode}
52                                                                  \{
53     \textcolor{comment}{//cout << "Comparing (" << f.first << ", " << f.second <<")" << " (" << s.first << ", " << s.second
       <<")" << endl;}
54     \textcolor{keywordflow}{if}(f.first < s.first) \{
55         \textcolor{keywordflow}{return} \textcolor{keyword}{true};
56     \}
57     \textcolor{keywordflow}{if} (f.first > s.first) \{
58         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
59     \}
60     \textcolor{keywordflow}{return} f.second<s.second;
61 \}
\end{DoxyCode}
\index{origin.\+h@{origin.\+h}!ordered\+Y\+Sort@{ordered\+Y\+Sort}}
\index{ordered\+Y\+Sort@{ordered\+Y\+Sort}!origin.\+h@{origin.\+h}}
\subsubsection[{\texorpdfstring{ordered\+Y\+Sort(pair$<$ double, double $>$ \&f, pair$<$ double, double $>$ \&s)}{orderedYSort(pair< double, double > &f, pair< double, double > &s)}}]{\setlength{\rightskip}{0pt plus 5cm}bool ordered\+Y\+Sort (
\begin{DoxyParamCaption}
\item[{pair$<$ double, double $>$ \&}]{f, }
\item[{pair$<$ double, double $>$ \&}]{s}
\end{DoxyParamCaption}
)}\hypertarget{origin_8h_a4dc1f0518995effb5aa220fd58f3b8e8}{}\label{origin_8h_a4dc1f0518995effb5aa220fd58f3b8e8}


Comparator Function Sort by y coordinate. 

This function basically compares a pair of elements by the values of their y-\/coordinate and if x-\/xoordinate is equal then it checks for equality of x-\/coordinate 
\begin{DoxyCode}
66                                                                   \{
67     \textcolor{keywordflow}{if}(f.second < s.second) \{
68         \textcolor{keywordflow}{return} \textcolor{keyword}{true};
69     \}
70     \textcolor{keywordflow}{if} (f.second > s.second) \{
71         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
72     \}
73     \textcolor{keywordflow}{return} f.first<s.first;
74 \}
\end{DoxyCode}
\index{origin.\+h@{origin.\+h}!orientation@{orientation}}
\index{orientation@{orientation}!origin.\+h@{origin.\+h}}
\subsubsection[{\texorpdfstring{orientation(pair$<$ double, double $>$ a, pair$<$ double, double $>$ b, pair$<$ double, double $>$ c)}{orientation(pair< double, double > a, pair< double, double > b, pair< double, double > c)}}]{\setlength{\rightskip}{0pt plus 5cm}int orientation (
\begin{DoxyParamCaption}
\item[{pair$<$ double, double $>$}]{a, }
\item[{pair$<$ double, double $>$}]{b, }
\item[{pair$<$ double, double $>$}]{c}
\end{DoxyParamCaption}
)}\hypertarget{origin_8h_a6edb8cd3a06d478bf1b50ae13f8af565}{}\label{origin_8h_a6edb8cd3a06d478bf1b50ae13f8af565}


Orientation. 

This function is used to calculate orientation of 3 points namely clockwise, anticlockwise and collinear. The idea here is to to get the difference between slopes of 2 lines by assuming a particular direction as a result the result obtained determines the direction of turn of the three points. 
\begin{DoxyCode}
33                                                                                         \{
34     \textcolor{keywordtype}{double} m1, m2, dif;
35     dif = (b.second - a.second)*(c.first-b.first) - (b.first-a.first)* (c.second - b.second);
36     cout << \textcolor{stringliteral}{"Difference in Slopes "} << dif<<endl;
37     \textcolor{keywordflow}{if}(dif == 0) \{
38         cout << \textcolor{stringliteral}{"COLLINEAR\(\backslash\)n"};
39         \textcolor{keywordflow}{return} \hyperlink{origin_8h_a105caa178db222564f6fab1433ae289b}{COLLINEAR};
40     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (dif > 0 ) \{
41         cout << \textcolor{stringliteral}{"CLOCKWISE\(\backslash\)n"};
42         \textcolor{keywordflow}{return} \hyperlink{origin_8h_ab97a98583824a9ef7d480fe8fdca33cf}{CLOCKWISE};
43     \} \textcolor{keywordflow}{else} \{
44         cout << \textcolor{stringliteral}{"ANTICLOCKWISE\(\backslash\)n"};
45         \textcolor{keywordflow}{return} \hyperlink{origin_8h_a289ba85c8fefbfdb6cc4927dbf948940}{ANTICLOCKWISE};
46     \}
47 \}
\end{DoxyCode}
\index{origin.\+h@{origin.\+h}!print\+Vector\+Data@{print\+Vector\+Data}}
\index{print\+Vector\+Data@{print\+Vector\+Data}!origin.\+h@{origin.\+h}}
\subsubsection[{\texorpdfstring{print\+Vector\+Data(int len, vector$<$ pair$<$ double, double $>$ $>$ v, string s)}{printVectorData(int len, vector< pair< double, double > > v, string s)}}]{\setlength{\rightskip}{0pt plus 5cm}void print\+Vector\+Data (
\begin{DoxyParamCaption}
\item[{int}]{len, }
\item[{vector$<$ pair$<$ double, double $>$ $>$}]{v, }
\item[{string}]{s}
\end{DoxyParamCaption}
)}\hypertarget{origin_8h_a4d6ea05a2f5f54cf53c8ce3687f0ae92}{}\label{origin_8h_a4d6ea05a2f5f54cf53c8ce3687f0ae92}


Print Function. 

Prints content of the vector. Used for {\bfseries output formatting} 
\begin{DoxyCode}
103                                                                          \{
104     \textcolor{keywordtype}{int} i;
105     cout << s << v.size() << endl;
106     \textcolor{keywordflow}{for}(i=0;i<len;i++)
107         cout << v[i].first <<\textcolor{stringliteral}{" "} << v[i].second <<endl;
108 \}
\end{DoxyCode}


\subsection{Variable Documentation}
\index{origin.\+h@{origin.\+h}!indices@{indices}}
\index{indices@{indices}!origin.\+h@{origin.\+h}}
\subsubsection[{\texorpdfstring{indices}{indices}}]{\setlength{\rightskip}{0pt plus 5cm}vector$<$int$>$ indices}\hypertarget{origin_8h_a09f477f5f8ac23bab833383ce19845e2}{}\label{origin_8h_a09f477f5f8ac23bab833383ce19845e2}
\index{origin.\+h@{origin.\+h}!P0@{P0}}
\index{P0@{P0}!origin.\+h@{origin.\+h}}
\subsubsection[{\texorpdfstring{P0}{P0}}]{\setlength{\rightskip}{0pt plus 5cm}pair$<$double ,double $>$ P0}\hypertarget{origin_8h_adacb3282d7a9fb184f695409085f0f0c}{}\label{origin_8h_adacb3282d7a9fb184f695409085f0f0c}


a double value which stores the centre about which polar ordering is to be done 

