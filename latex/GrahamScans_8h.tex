\hypertarget{GrahamScans_8h}{}\section{Graham\+Scans.\+h File Reference}
\label{GrahamScans_8h}\index{Graham\+Scans.\+h@{Graham\+Scans.\+h}}
{\ttfamily \#include $<$iostream$>$}\\*
{\ttfamily \#include $<$bits/stdc++.\+h$>$}\\*
{\ttfamily \#include \char`\"{}origin.\+h\char`\"{}}\\*
Include dependency graph for Graham\+Scans.\+h\+:
% FIG 0
This graph shows which files directly or indirectly include this file\+:
% FIG 1
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
pair$<$ double, double $>$ \hyperlink{GrahamScans_8h_a9d4fb0cfb76b375de4e541983fc8546a}{next\+\_\+to\+\_\+top} (stack$<$ pair$<$ double, double $>$ $>$ S)
\item 
double \hyperlink{GrahamScans_8h_a1d58f00b26e0821c57293f36fe29e7cd}{exec\+Graham\+Scans} (vector$<$ pair$<$ double, double $>$ $>$ Points)
\begin{DoxyCompactList}\small\item\em {\bfseries Graham Scans Algorithm Implementation} \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Function Documentation}
\index{Graham\+Scans.\+h@{Graham\+Scans.\+h}!exec\+Graham\+Scans@{exec\+Graham\+Scans}}
\index{exec\+Graham\+Scans@{exec\+Graham\+Scans}!Graham\+Scans.\+h@{Graham\+Scans.\+h}}
\subsubsection[{\texorpdfstring{exec\+Graham\+Scans(vector$<$ pair$<$ double, double $>$ $>$ Points)}{execGrahamScans(vector< pair< double, double > > Points)}}]{\setlength{\rightskip}{0pt plus 5cm}double exec\+Graham\+Scans (
\begin{DoxyParamCaption}
\item[{vector$<$ pair$<$ double, double $>$ $>$}]{Points}
\end{DoxyParamCaption}
)}\hypertarget{GrahamScans_8h_a1d58f00b26e0821c57293f36fe29e7cd}{}\label{GrahamScans_8h_a1d58f00b26e0821c57293f36fe29e7cd}


{\bfseries Graham Scans Algorithm Implementation} 


\begin{DoxyEnumerate}
\item First Step is to sort points with respect to the polar coordinates.~\newline

\item After getting the closed path, the next step is to get all points in the path and remove concave points on this.~\newline

\item We accept and reject based on orientation of 3 points selected. 
\end{DoxyEnumerate}
\begin{DoxyCode}
27                                                              \{
28     \textcolor{comment}{//clock\_t time\_taken;}
29     \textcolor{comment}{//time\_taken = clock();}
30     \textcolor{keywordtype}{int} len, i, min = 0;
31     len = int(Points.size());
32     \textcolor{keywordtype}{double} y\_min = Points[0].second; \textcolor{comment}{// a **double** value which gets the point with lowest y-coordinate}
33     pair<double, double> temp;
34     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 1; i < len; i++)
35     \{
36         \textcolor{keywordtype}{double} y = Points[i].second;
37         \textcolor{keywordflow}{if} ((y < y\_min) || (y\_min == y &&
38                             Points[i].first < Points[min].first))
39             y\_min = Points[i].second, min = i;
40     \}
41 
42     temp = Points[min];
43     Points[min] = Points[0];
44     Points[0] = temp;
45 
46     \textcolor{comment}{//printVectorData(len,Points, "Get Values after minimum y-coordinate\(\backslash\)n");}
47     \hyperlink{origin_8h_adacb3282d7a9fb184f695409085f0f0c}{P0} = Points[0];     \textcolor{comment}{// P0 denotes Central Point for Comparision}
48     Points.erase(Points.begin());
49     sort(Points.begin(), Points.end(), \hyperlink{origin_8h_ab4d553464b44f7c3f45a7ad69b98772c}{orderByPolar});
50 
51     len = int(Points.size());
52     \textcolor{comment}{//printVectorData(len,Points, "Ordered by Polar Angles");}
53     stack<pair<double , double > > \hyperlink{Andrews_8h_a531ddaca865c8d7a7a3f636e7a3adb6f}{convex\_hull}; \textcolor{comment}{// A **stack data structure** which stores the
       coordinates. Form the Hull by processing the remaining points}
54     convex\_hull.push(\hyperlink{origin_8h_adacb3282d7a9fb184f695409085f0f0c}{P0});
55     convex\_hull.push(Points[0]);
56     convex\_hull.push(Points[1]);
57 
58     \textcolor{keywordflow}{for} (i = 2; i < len; i++) \{
59 
60         \textcolor{keywordflow}{while} (\hyperlink{origin_8h_a6edb8cd3a06d478bf1b50ae13f8af565}{orientation}(\hyperlink{GrahamScans_8h_a9d4fb0cfb76b375de4e541983fc8546a}{next\_to\_top}(convex\_hull), convex\_hull.top(), Points[i]) !=
       3) \{
61             \textcolor{keywordflow}{if} (convex\_hull.size() < 3) \{ \textcolor{keywordflow}{break};\}
62             convex\_hull.pop();
63         \}
64         convex\_hull.push(Points[i]);
65     \}
66     cout << \textcolor{stringliteral}{"Using Graham Scans Algorithm\(\backslash\)n---\(\backslash\)n"} << endl;
67     \textcolor{keywordflow}{while} (!convex\_hull.empty())
68     \{
69         pair<double , double > point = convex\_hull.top();
70         cout << point.first << \textcolor{stringliteral}{", "} << point.second << endl;
71         convex\_hull.pop();
72     \}
73     \textcolor{comment}{//time\_taken = clock() - time\_taken;}
74     \textcolor{keywordflow}{return} 0;
75 \}
\end{DoxyCode}
\index{Graham\+Scans.\+h@{Graham\+Scans.\+h}!next\+\_\+to\+\_\+top@{next\+\_\+to\+\_\+top}}
\index{next\+\_\+to\+\_\+top@{next\+\_\+to\+\_\+top}!Graham\+Scans.\+h@{Graham\+Scans.\+h}}
\subsubsection[{\texorpdfstring{next\+\_\+to\+\_\+top(stack$<$ pair$<$ double, double $>$ $>$ S)}{next_to_top(stack< pair< double, double > > S)}}]{\setlength{\rightskip}{0pt plus 5cm}pair$<$double , double $>$ next\+\_\+to\+\_\+top (
\begin{DoxyParamCaption}
\item[{stack$<$ pair$<$ double, double $>$ $>$}]{S}
\end{DoxyParamCaption}
)}\hypertarget{GrahamScans_8h_a9d4fb0cfb76b375de4e541983fc8546a}{}\label{GrahamScans_8h_a9d4fb0cfb76b375de4e541983fc8546a}

\begin{DoxyCode}
13                                                                      \{
14     pair<double , double > point = S.top();
15     S.pop();
16     pair<double , double > res = S.top();
17     S.push(point);
18     \textcolor{keywordflow}{return} res;
19 \}
\end{DoxyCode}
